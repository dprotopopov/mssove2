using System;
using System.Linq;
using System.Text;

namespace BBSLib.Cryptography
{
    /// <summary>
    ///     https://ru.wikipedia.org/wiki/RC4
    ///     Потоковый шифр RC4 был создан Рональдом Ривестом, сотрудником компании «RSA Security», в 1987 году. Сокращение
    ///     «RC4» официально обозначает «Rivest cipher 4» или «шифр Ривеста» («4» - номер версии; см. RC2, RC5, RC6; RC1
    ///     никогда не публиковался; RC3 разрабатывался, но в нём была найдена уязвимость), но его часто считают сокращением от
    ///     «Ron’s code» («код Рона»)[2].
    ///     В течение семи лет шифр являлся коммерческой тайной, и точное описание алгоритма предоставлялось только после
    ///     подписания соглашения о неразглашении, но в сентябре 1994 года его описание было анонимно отправлено в список
    ///     рассылки (англ. mailing list) «Cypherpunks»[3]. Вскоре описание RC4 было опубликовано в группе новостей usenet
    ///     «sci.crypt». Оттуда исходный код попал на множество сайтов в сети Интернет. Опубликованный алгоритм на выходе
    ///     выдавал шифротексты, совпадающие с шифротекстами, выдаваемыми подлинным RC4. Обладатели легальных копий исходного
    ///     кода RC4 подтвердили идентичность алгоритмов при различиях в обозначениях и структуре программы.
    ///     Поскольку данный алгоритм известен, он более не является коммерческой тайной. Однако, название «RC4» является
    ///     торговой маркой компании «RSA Security». Чтобы избежать возможных претензий со стороны владельца торговой марки,
    ///     шифр иногда называют «ARCFOUR» или «ARC4», имея в виду англ. alleged RC4 — «предполагаемый» RC4 (поскольку «RSA
    ///     Security» официально не опубликовала алгоритм).
    ///     Алгоритм шифрования RC4 применяется в некоторых широко распространённых стандартах и протоколах шифрования
    ///     (например, WEP, WPA, SSL и TLS).
    ///     RC4 стал популярен благодаря:
    ///     простоте его аппаратной и программной реализации;
    ///     высокой скорости работы алгоритма в обоих случаях.
    ///     В США длина ключа, рекомендуемая для использования внутри страны, равна 128 битам. Соглашение, заключённое между
    ///     «SPA» (англ. software publishers association) и правительством США, разрешило экспортировать шифры RC4 с длиной
    ///     ключа до 40 бит. 56-и битные ключи разрешено использовать заграничным отделениям американских компаний[4].
    /// </summary>
    public class Arcfour
    {
        private int[] _key; // Ключевое слово

        /// <summary>
        ///     Алгоритм также известен как «key-scheduling algorithm» или «KSA». Этот алгоритм использует ключ, подаваемый на вход
        ///     пользователем, сохранённый в Key, и имеющий длину L байт. Инициализация начинается с заполнения массива S, далее
        ///     этот массив перемешивается путём перестановок, определяемых ключом. Так как только одно действие выполняется над S,
        ///     то должно выполняться утверждение, что S всегда содержит один набор значений , который был дан при первоначальной
        ///     инициализации (S[i] := i).
        /// </summary>
        public void Ksa(int[] s)
        {
            var len = s.Length;
            var keyLength = _key.Length;
            var key = _key;
            Array.Copy(Enumerable.Range(0, len).ToArray(), s, len);
            for (int i = 0, j = 0; i < len; i++)
            {
                j = (j + s[i] + key[i%keyLength])%len;
                var temp = s[i];
                s[i] = s[j];
                s[j] = temp;
            }
        }

        /// <summary>
        ///     Эта часть алгоритма называется генератором псевдослучайной последовательности (англ. pseudo-random generation
        ///     algorithm, PRGA). Генератор ключевого потока RC4 переставляет значения, хранящиеся в S. В одном цикле RC4
        ///     определяется одно n-битное слово K из ключевого потока.
        /// </summary>
        public void Prga(byte[] k)
        {
            var len = k.Length;
            var keyLength = _key.Length;
            var s = new int[256];
            Ksa(s);
            for (int index = 0, i = 0, j = 0; index < len; index++)
            {
                i = (i + 1)%keyLength;
                j = (j + s[i])%keyLength;
                var temp = s[i];
                s[i] = s[j];
                s[j] = temp;
                var t = (s[i] + s[j])%keyLength;
                k[index] = (byte) s[t];
            }
        }

        public void SetKey(string keyText)
        {
            var bytes = Encoding.GetEncoding(0).GetBytes(keyText);
            var key = new int[bytes.Length];
            for (var index = 0; index < bytes.Length; index++) key[index] = bytes[index];
            _key = key;
        }
    }
}